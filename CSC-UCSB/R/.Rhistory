allData <- allData %>% mutate(Embarked = fillEmbarked(Embarked))
# There are so many NAs in Cabin 1024 out of 1309 observations. So, let's create a binary
# value has.cabin. Then remove the Cabin column
allData <- allData %>% mutate(has.cabin = ifelse(is.na(Cabin), 0, 1)) %>% mutate(Cabin = NULL)
# Check that all NAs are dealt with
naCols <- allData %>% summarize_all(funs(totNA))
if (any(naCols > 0)) cat("There are still NA's to fix!")
# Now, split back into train and test
train <- allData %>% filter(is.train == 1) %>% mutate(is.train = NULL) %>%
left_join(survival, by = "PassengerId")
test <- allData %>% filter(is.train == 0) %>% mutate(is.train = NULL)
train$Embarked
test$Embarked
train
train <- train %>% select(-c(Name, Ticket, PassengerId))
train
trainMatrix <- model.matrix(Survived ~., data = train)[-1]
test <- test %>% select(-c(Name, Ticket, PassengerId))
trainMatrix <- model.matrix(Survived ~., data = train)[-1]
testMatrix <- model.matrix(Survived ~., data = test)[-1]
testMatrix <- model.matrix(~, data = test)[-1]
testMatrix <- model.matrix(data = test)[-1]
testMatrix <- model.matrix(~., data = test)[-1]
head(trainMatrix)
trainMatrix <- model.matrix(Survived ~., data = train)[,-1]
testMatrix <- model.matrix(~., data = test)[,-1]
head(trainMatrix)
foo <- train %>% mutate_at(cols(Pcalss,Sex,Embarked), funs(as.factor))
head(train)
foo <- train %>% mutate_at(cols(Pccass,Sex,Embarked), funs(as.factor))
foo <- train %>% mutate_at(cols(Pclass,Sex,Embarked), funs(as.factor))
foo <- train %>% mutate_at(cols(Pclass,Sex,Embarked), funs(as.factor))
train
foo <- train %>% mutate_at(.cols(Pclass,Sex,Embarked), funs(as.factor))
foo <- train %>% mutate_at(.cols=(Pclass,Sex,Embarked), funs(as.factor))
foo <- train %>% mutate_at(cols(Sex,Embarked), funs(as.factor))
foo <- train %>% mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
foo
# Burak Himmetoglu
# 10-25-2016
# bhimmetoglu@ucsb.edu
#
#
# Example: Titanic survival prediction
#
library(readr)
library(dplyr)
library(Matrix)
library(glmnet)
library(foreach)
library(doMC)
## Parallel
registerDoMC()
##### Part 1: Read and clean the data #####
# Read data
train <- read_csv("./data/train.csv", col_types = 'iiiccdiicdcc')
test <- read_csv("./data/test.csv", col_types = 'iiccdiicdcc')
## Let's merge train and test
# First remove Survied column and keep it in a vector
survival <- select(train, c(Survived,PassengerId))
train <- mutate(train, Survived = NULL) %>% mutate(is.train = 1) # Flag training data with is.train = 1
test <- mutate(test, is.train = 0) # Flag test data with is.train = 0
allData <- rbind(train,test)
# Find NA's
totNA <- function(x) { sum(is.na(x)) } # Finds total number of NA's in a given vector x
naCols <- allData %>% summarize_all(funs(totNA)) # For all the columns, finds how many NAs there are
cat("Number of NA's I have found: \n")
naCols
## Fill the NA's
# Function for filling the NAs with medians
fillMedian <- function(x){
m <- median(x, na.rm = TRUE)
x[is.na(x)] <- m
x
}
# Fill NAs in Age and Fare with their median values
allData <- allData %>% mutate(Age = fillMedian(Age)) %>% mutate(Fare = fillMedian(Fare))
# Find the most common embarked value
mostCommonEmbarked <- allData %>% group_by(Embarked) %>% summarize(nEmb = n()) %>%
arrange(desc(nEmb)) %>% slice(1)
mostCommonEmbarked <- mostCommonEmbarked$Embarked # Pick the name
# Fill the NAs in Embarked with mostCommonEmbarked
fillEmbarked <- function(x){ x[is.na(x)] <- mostCommonEmbarked; x }
allData <- allData %>% mutate(Embarked = fillEmbarked(Embarked))
# There are so many NAs in Cabin 1024 out of 1309 observations. So, let's create a binary
# value has.cabin. Then remove the Cabin column
allData <- allData %>% mutate(has.cabin = ifelse(is.na(Cabin), 0, 1)) %>% mutate(Cabin = NULL)
# Check that all NAs are dealt with
naCols <- allData %>% summarize_all(funs(totNA))
if (any(naCols > 0)) cat("There are still NA's to fix!")
# Now, split back into train and test
train <- allData %>% filter(is.train == 1) %>% mutate(is.train = NULL) %>%
left_join(survival, by = "PassengerId")
test <- allData %>% filter(is.train == 0) %>% mutate(is.train = NULL)
train <- train %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
test <- test %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
trainMatrix <- model.matrix(Survived ~., data = train)[,-1]
testMatrix <- model.matrix(~., data = test)[,-1]
cat("The model Matrix turns factors into binary values:\n")
head(trainMatrix)
head(testMatrix)
mostCommonEmbarked <- allData %>% group_by(Embarked) %>% summarize(nEmb = n()) %>%
arrange(desc(nEmb)) %>% slice(1)
mostCommonEmbarked
mostCommonEmbarked <- allData %>% group_by(Embarked) %>% summarize(nEmb = n()) %>%
arrange(desc(nEmb)) #%>% slice(1)
mostCommonEmbarked
table(allData$Embarked)
# Burak Himmetoglu
# 10-25-2016
# bhimmetoglu@ucsb.edu
#
#
# Example: Titanic survival prediction
#
library(readr)
library(dplyr)
library(Matrix)
library(glmnet)
library(foreach)
library(doMC)
## Parallel
registerDoMC()
##### Part 1: Read and clean the data #####
# Read data
train <- read_csv("./data/train.csv", col_types = 'iiiccdiicdcc')
test <- read_csv("./data/test.csv", col_types = 'iiccdiicdcc')
## Let's merge train and test
# First remove Survied column and keep it in a vector
survival <- select(train, c(Survived,PassengerId))
train <- mutate(train, Survived = NULL) %>% mutate(is.train = 1) # Flag training data with is.train = 1
test <- mutate(test, is.train = 0) # Flag test data with is.train = 0
allData <- rbind(train,test)
# Find NA's
totNA <- function(x) { sum(is.na(x)) } # Finds total number of NA's in a given vector x
naCols <- allData %>% summarize_all(funs(totNA)) # For all the columns, finds how many NAs there are
cat("Number of NA's I have found: \n")
naCols
## Fill the NA's
# Function for filling the NAs with medians
fillMedian <- function(x){
m <- median(x, na.rm = TRUE)
x[is.na(x)] <- m
x
}
# Fill NAs in Age and Fare with their median values
allData <- allData %>% mutate(Age = fillMedian(Age)) %>% mutate(Fare = fillMedian(Fare))
# Find the most common embarked value
mostCommonEmbarked <- allData %>% group_by(Embarked) %>% summarize(nEmb = n()) %>%
arrange(desc(nEmb)) %>% slice(1)
mostCommonEmbarked <- mostCommonEmbarked$Embarked # Pick the name
table(allData$Embarked)
fillEmbarked <- function(x){ x[is.na(x)] <- mostCommonEmbarked; x }
allData <- allData %>% mutate(Embarked = fillEmbarked(Embarked))
table(allData$Embarked)
allData <- allData %>% mutate(has.cabin = ifelse(is.na(Cabin), 0, 1)) %>% mutate(Cabin = NULL)
naCols <- allData %>% summarize_all(funs(totNA))
if (any(naCols > 0)) cat("There are still NA's to fix!")
train <- allData %>% filter(is.train == 1) %>% mutate(is.train = NULL) %>%
left_join(survival, by = "PassengerId")
test <- allData %>% filter(is.train == 0) %>% mutate(is.train = NULL)
head(train)
head(train$Embarked)
train <- train %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
test <- test %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
trainMatrix <- model.matrix(Survived ~., data = train)[,-1]
testMatrix <- model.matrix(~., data = test)[,-1]
head(trainMatrix)
?"glmnet"
dim(train)[1]
i.tr <- sample(1:dim(train)[1], 0.7*floor(dim(train)[1]), replace = FALSE)
str(train$Survived)
mod.logreg <- glmnet(x = trainMatrix, y = train$Survived, family = "binomial", alpha = 0.1)
mod.logreg
plot(mod.logreg)
mod.logreg$lambda
mod.logreg$df
mod.logreg <- glmnet(x = trainMatrix, y = train$Survived, family = "binomial")
mod.logreg
mod.logreg$lambda
mod.logreg$nulldev
mod.logreg$df
mod.logreg$a0
mod.logreg$classnames
mod.logreg$offset
mod.logreg
ypred <- predict(mod.logreg, newx = trainMatrix)
ypred
ypred
mmod.logreg
mod.logreg
mod.logreg$lambda
?cv.glmnet
mod.logreg <- cv.glmnet(x = trainMatrix, y = train$Survived, nfolds = 10, family = "binomial", parallel = TRUE)
mod.logreg
mod.logreg$glmnet.fit
mod.logreg$glmnet.fit$lambda
mod.logreg$lambda.min
bestLambda <- mod.logreg$lambda.min
plot(mod.logreg)
cv.logreg <- cv.glmnet(x = trainMatrix, y = train$Survived, nfolds = 10, family = "binomial", parallel = TRUE)
mod.logred <- glmnet(x = trainMatrix, y = train$Survived, family = "binomial", lambda = bestLambda)
mod.logreg <- glmnet(x = trainMatrix, y = train$Survived, family = "binomial", lambda = bestLambda)
ypred <- predict(mod.logreg, newx = trainMatrix)
ypred
str(train$Survived)
ytrain <- as.factor(train$Survived)
ytrain
levels(train)
levels(ytrain)
ytrain <- as.factor(train$Survived)
cv.logreg <- cv.glmnet(x = trainMatrix, y = ytrain, nfolds = 10, family = "binomial", parallel = TRUE)
bestLambda <- mod.logreg$lambda.min
bestLambda
bestLambda <- cv.logreg$lambda.min
bestLambda
mod.logreg <- glmnet(x = trainMatrix, y = ytrain, family = "binomial", lambda = bestLambda)
ypred <- predict(mod.logreg, newx = trainMatrix)
head(ypred)
?predict.glmnet
ypred <- predict(mod.logreg, newx = trainMatrix, type = "response")
head(ypred)
?auc()
auc <- roc(ytrain, ypred)
library(ROCR)
auc <- roc(ytrain, ypred)
library(pROC)
ypred <- predict(mod.logreg, newx = trainMatrix, type = "class") # Probability of survival is predicted
head(ypred)
ypred <- predict(mod.logreg, newx = trainMatrix, type = "response") # Probability of survival is predicted
auc <- roc(ytrain, ypred)
auc
plot(auc)
testSurvived <- predict(mod.logreg, newx = testMatrix, type = "class")
# Burak Himmetoglu
# 10-25-2016
# bhimmetoglu@ucsb.edu
#
#
# Example: Titanic survival prediction
#
library(readr)
library(dplyr)
library(Matrix)
library(glmnet)
library(foreach)
library(doMC)
## Parallel
registerDoMC()
##### Part 1: Read and clean the data #####
# Read data
train <- read_csv("./data/train.csv", col_types = 'iiiccdiicdcc')
test <- read_csv("./data/test.csv", col_types = 'iiccdiicdcc')
## Let's merge train and test
# First remove Survied column and keep it in a vector
survival <- select(train, c(Survived,PassengerId))
train <- mutate(train, Survived = NULL) %>% mutate(is.train = 1) # Flag training data with is.train = 1
test <- mutate(test, is.train = 0) # Flag test data with is.train = 0
allData <- rbind(train,test)
# Find NA's
totNA <- function(x) { sum(is.na(x)) } # Finds total number of NA's in a given vector x
naCols <- allData %>% summarize_all(funs(totNA)) # For all the columns, finds how many NAs there are
cat("Number of NA's I have found: \n")
naCols
## Fill the NA's
# Function for filling the NAs with medians
fillMedian <- function(x){
m <- median(x, na.rm = TRUE)
x[is.na(x)] <- m
x
}
# Fill NAs in Age and Fare with their median values
allData <- allData %>% mutate(Age = fillMedian(Age)) %>% mutate(Fare = fillMedian(Fare))
# Find the most common embarked value
mostCommonEmbarked <- allData %>% group_by(Embarked) %>% summarize(nEmb = n()) %>%
arrange(desc(nEmb)) %>% slice(1)
mostCommonEmbarked <- mostCommonEmbarked$Embarked # Pick the name
# Fill the NAs in Embarked with mostCommonEmbarked
fillEmbarked <- function(x){ x[is.na(x)] <- mostCommonEmbarked; x }
allData <- allData %>% mutate(Embarked = fillEmbarked(Embarked))
# There are so many NAs in Cabin 1024 out of 1309 observations. So, let's create a binary
# value has.cabin. Then remove the Cabin column
allData <- allData %>% mutate(has.cabin = ifelse(is.na(Cabin), 0, 1)) %>% mutate(Cabin = NULL)
# Check that all NAs are dealt with
naCols <- allData %>% summarize_all(funs(totNA))
if (any(naCols > 0)) cat("There are still NA's to fix!")
# Now, split back into train and test
train <- allData %>% filter(is.train == 1) %>% mutate(is.train = NULL) %>%
left_join(survival, by = "PassengerId")
test <- allData %>% filter(is.train == 0) %>% mutate(is.train = NULL)
##### Part 2: Model training #####
# Let us remove Name, Ticket and PassangerId as predictors and assign factor variables
train <- train %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
testId <- test %>% select(PassengerId) # Save PassengerId for later
test <- test %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
# Let us contruct model matrices from train and test
trainMatrix <- model.matrix(Survived ~., data = train)[,-1]
testMatrix <- model.matrix(~., data = test)[,-1]
cat("The model Matrix turns factors into binary values:\n")
head(trainMatrix)
ytrain <- as.factor(train$Survived)
cv.logreg <- cv.glmnet(x = trainMatrix, y = ytrain, nfolds = 10, family = "binomial", parallel = TRUE)
bestLambda <- cv.logreg$lambda.min
mod.logreg <- glmnet(x = trainMatrix, y = ytrain, family = "binomial", lambda = bestLambda)
ypred <- predict(mod.logreg, newx = trainMatrix, type = "response") # Probability of survival is predicted
auc <- roc(ytrain, ypred)
auc
testSurvived <- predict(mod.logreg, newx = testMatrix, type = "class")
submit <- rbind(testId, testSurvived)
submit <- cbind(testId, testSurvived)
head(submit)
submit <- cbind(testId, testSurvived); colnames(submit) <- c("PasengerId, Survived")
submit <- as.data.frame(submit)
head(submit)
submit <- cbind(testId, testSurvived); colnames(submit) <- c("PasengerId, Survived")
submit
str(submit)
head(submit)
submit <- cbind(testId, testSurvived);
head(submit)
colnames(submit) <- c("PasengerId", "Survived")
head(submit)
?write_csv
write_csv(submit, file = "submission.csv", row.names = FALSE, quote = FALSE)
write_csv(submit, file = "submission.csv")
write_csv(submit, path = "submission.csv")
# Burak Himmetoglu
# 10-25-2016
# bhimmetoglu@ucsb.edu
#
#
# Titanic survival prediction
# Data available from: https://www.kaggle.com/c/titanic
#
# Libraries
library(readr)
library(dplyr)
library(Matrix)
library(glmnet)
library(foreach)
library(doMC)
## Parallel
registerDoMC()
##### Part 1: Read and clean the data #####
# Read data
train <- read_csv("./data/train.csv", col_types = 'iiiccdiicdcc')
test <- read_csv("./data/test.csv", col_types = 'iiccdiicdcc')
## Let's merge train and test
# First remove Survied column and keep it in a vector
survival <- select(train, c(Survived,PassengerId))
train <- mutate(train, Survived = NULL) %>% mutate(is.train = 1) # Flag training data with is.train = 1
test <- mutate(test, is.train = 0) # Flag test data with is.train = 0
allData <- rbind(train,test)
# Find NA's
totNA <- function(x) { sum(is.na(x)) } # Finds total number of NA's in a given vector x
naCols <- allData %>% summarize_all(funs(totNA)) # For all the columns, finds how many NAs there are
cat("Number of NA's I have found: \n")
naCols
## Fill the NA's
# Function for filling the NAs with medians
fillMedian <- function(x){
m <- median(x, na.rm = TRUE)
x[is.na(x)] <- m
x
}
# Fill NAs in Age and Fare with their median values
allData <- allData %>% mutate(Age = fillMedian(Age)) %>% mutate(Fare = fillMedian(Fare))
# Find the most common embarked value
mostCommonEmbarked <- allData %>% group_by(Embarked) %>% summarize(nEmb = n()) %>%
arrange(desc(nEmb)) %>% slice(1)
mostCommonEmbarked <- mostCommonEmbarked$Embarked # Pick the name
# Fill the NAs in Embarked with mostCommonEmbarked
fillEmbarked <- function(x){ x[is.na(x)] <- mostCommonEmbarked; x }
allData <- allData %>% mutate(Embarked = fillEmbarked(Embarked))
# There are so many NAs in Cabin 1024 out of 1309 observations. So, let's create a binary
# predictor: has.cabin. Then remove the Cabin column from predictors
allData <- allData %>% mutate(has.cabin = ifelse(is.na(Cabin), 0, 1)) %>% mutate(Cabin = NULL)
# Check that all NAs are dealt with
naCols <- allData %>% summarize_all(funs(totNA))
if (any(naCols > 0)) cat("There are still NA's to fix!")
# Now, split back into train and test
train <- allData %>% filter(is.train == 1) %>% mutate(is.train = NULL) %>%
left_join(survival, by = "PassengerId")
test <- allData %>% filter(is.train == 0) %>% mutate(is.train = NULL)
train <- train %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
testId <- test %>% select(PassengerId) # Save PassengerId for later
test <- test %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
trainMatrix <- model.matrix(Survived ~., data = train)[,-1]
testMatrix <- model.matrix(~., data = test)[,-1]
cat("The model Matrix turns factors into binary values:\n")
head(trainMatrix)
ytrain <- as.factor(train$Survived)
cv.logreg <- cv.glmnet(x = trainMatrix, y = ytrain, nfolds = 10, family = "binomial", parallel = TRUE)
bestLambda <- cv.logreg$lambda.min
mod.logreg <- glmnet(x = trainMatrix, y = ytrain, family = "binomial", lambda = bestLambda)
ypred <- predict(mod.logreg, newx = trainMatrix, type = "response") # Probability of survival is predicted
auc <- roc(ytrain, ypred)
auc
plot(auc)
testSurvived <- predict(mod.logreg, newx = testMatrix, type = "class")
submit <- cbind(testId, testSurvived);
colnames(submit) <- c("PasengerId", "Survived")
# Finally, print
write_csv(submit, path = "submission.csv")
?gc
# Burak Himmetoglu
# 10-25-2016
# bhimmetoglu@ucsb.edu
#
#
# Titanic survival prediction
# Data available from: https://www.kaggle.com/c/titanic
#
# Libraries
library(readr)
library(dplyr)
library(Matrix)
library(glmnet)
library(foreach)
library(doMC)
## Parallel
registerDoMC()
##### Part 1: Read and clean the data #####
# Read data
train <- read_csv("./data/train.csv", col_types = 'iiiccdiicdcc')
test <- read_csv("./data/test.csv", col_types = 'iiccdiicdcc')
## Let's merge train and test
# First remove Survied column and keep it in a vector
survival <- select(train, c(Survived,PassengerId))
train <- mutate(train, Survived = NULL) %>% mutate(is.train = 1) # Flag training data with is.train = 1
test <- mutate(test, is.train = 0) # Flag test data with is.train = 0
allData <- rbind(train,test)
# Find NA's
totNA <- function(x) { sum(is.na(x)) } # Finds total number of NA's in a given vector x
naCols <- allData %>% summarize_all(funs(totNA)) # For all the columns, finds how many NAs there are
cat("Number of NA's I have found: \n")
naCols
## Fill the NA's
# Function for filling the NAs with medians
fillMedian <- function(x){
m <- median(x, na.rm = TRUE)
x[is.na(x)] <- m
x
}
# Fill NAs in Age and Fare with their median values
allData <- allData %>% mutate(Age = fillMedian(Age)) %>% mutate(Fare = fillMedian(Fare))
# Find the most common embarked value
mostCommonEmbarked <- allData %>% group_by(Embarked) %>% summarize(nEmb = n()) %>%
arrange(desc(nEmb)) %>% slice(1)
mostCommonEmbarked <- mostCommonEmbarked$Embarked # Pick the name
# Fill the NAs in Embarked with mostCommonEmbarked
fillEmbarked <- function(x){ x[is.na(x)] <- mostCommonEmbarked; x }
allData <- allData %>% mutate(Embarked = fillEmbarked(Embarked))
# There are so many NAs in Cabin 1024 out of 1309 observations. So, let's create a binary
# predictor: has.cabin. Then remove the Cabin column from predictors
allData <- allData %>% mutate(has.cabin = ifelse(is.na(Cabin), 0, 1)) %>% mutate(Cabin = NULL)
# Check that all NAs are dealt with
naCols <- allData %>% summarize_all(funs(totNA))
if (any(naCols > 0)) cat("There are still NA's to fix!")
# Now, split back into train and test
train <- allData %>% filter(is.train == 1) %>% mutate(is.train = NULL) %>%
left_join(survival, by = "PassengerId")
test <- allData %>% filter(is.train == 0) %>% mutate(is.train = NULL)
# Clean: Remove unnecessary variables. Then collect garbage
rm(allData,naCols,survival,fillEmbarked,fillMedian,totNA); gc()
##### Part 2: Model training #####
# Let us remove Name, Ticket and PassangerId as predictors and assign factor variables
train <- train %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
testId <- test %>% select(PassengerId) # Save PassengerId for later
test <- test %>% select(-c(Name, Ticket, PassengerId)) %>%
mutate_at(vars(Pclass,Sex,Embarked), funs(as.factor))
# Let us contruct model matrices from train and test
trainMatrix <- model.matrix(Survived ~., data = train)[,-1]
testMatrix <- model.matrix(~., data = test)[,-1]
# Take a peek at what they look like
cat("The model Matrix turns factors into binary values:\n")
head(trainMatrix)
# Notice that Pclass=1 and Embarked=C is chosen as reference levels by model.matrix
# e.g. Pclass2 = Pclass = 0 means the observarion has Pclass 1 (same for Embarked)
# Let us train a Regularized Logistic Regression Model by 10-fold cross-validation
ytrain <- as.factor(train$Survived)
cv.logreg <- cv.glmnet(x = trainMatrix, y = ytrain, nfolds = 10, family = "binomial", parallel = TRUE)
# Choose the best lambda (alpha = 1 is set by default)
bestLambda <- cv.logreg$lambda.min
# Now fit with the bestLambda
mod.logreg <- glmnet(x = trainMatrix, y = ytrain, family = "binomial", lambda = bestLambda)
ypred <- predict(mod.logreg, newx = trainMatrix, type = "response") # Probability of survival is predicted
# If you choose type = "class" 0's and 1's will be predicted:
# Prob >= 0.5 --> Survived = 1, Prob < 0.5 --> Survived = 0
# What is the area under the ROC curve? 0.86, not too bad for a simple model!
auc <- roc(ytrain, ypred)
auc
#plot(auc)
# Finally predict on test set on test set
testSurvived <- predict(mod.logreg, newx = testMatrix, type = "class")
# Bind with passangerId's
submit <- cbind(testId, testSurvived);
colnames(submit) <- c("PasengerId", "Survived")
# Finally, write on file. You can submit to Kaggle if you wish!
write_csv(submit, path = "submission.csv")
?registerDoMC
?cv.glmnet
?`%>%`
